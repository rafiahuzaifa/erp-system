const {{pascalCase entity.name}} = require('../models/{{pascalCase entity.name}}');

// Get all {{pluralize entity.name}} with search, filter, sort, pagination
exports.getAll = async (req, res) => {
  try {
    const {
      page = 1,
      limit = 20,
      sort = '-createdAt',
      search = '',
      ...filters
    } = req.query;

    const skip = (parseInt(page) - 1) * parseInt(limit);
    const query = {};

    // Text search across string fields
    if (search) {
      query.$or = [
{{#each entity.fields}}
{{#ifEq this.type "String"}}
        { {{camelCase this.name}}: { $regex: search, $options: 'i' } },
{{/ifEq}}
{{/each}}
      ].filter(Boolean);
      if (!query.$or.length) delete query.$or;
    }

    // Apply field-specific filters
{{#each entity.fields}}
{{#ifEq this.type "Enum"}}
    if (filters.{{camelCase this.name}}) query.{{camelCase this.name}} = filters.{{camelCase this.name}};
{{/ifEq}}
{{#ifEq this.type "Boolean"}}
    if (filters.{{camelCase this.name}} !== undefined) query.{{camelCase this.name}} = filters.{{camelCase this.name}} === 'true';
{{/ifEq}}
{{/each}}

    if (filters.startDate || filters.endDate) {
      query.createdAt = {};
      if (filters.startDate) query.createdAt.$gte = new Date(filters.startDate);
      if (filters.endDate) query.createdAt.$lte = new Date(filters.endDate);
    }

    const [items, total] = await Promise.all([
      {{pascalCase entity.name}}.find(query)
        .sort(sort)
        .skip(skip)
        .limit(parseInt(limit)){{#each entity.fields}}{{#if this.ref}}
        .populate('{{camelCase this.name}}'){{/if}}{{/each}},
      {{pascalCase entity.name}}.countDocuments(query)
    ]);

    res.json({
      data: items,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / parseInt(limit))
      }
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

// Get single {{entity.name}} by ID
exports.getById = async (req, res) => {
  try {
    const item = await {{pascalCase entity.name}}.findById(req.params.id){{#each entity.fields}}{{#if this.ref}}
      .populate('{{camelCase this.name}}'){{/if}}{{/each}};
    if (!item) return res.status(404).json({ error: '{{pascalCase entity.name}} not found' });
    res.json(item);
  } catch (error) {
    if (error.name === 'CastError') return res.status(400).json({ error: 'Invalid ID format' });
    res.status(500).json({ error: error.message });
  }
};

// Create new {{entity.name}} with validation
exports.create = async (req, res) => {
  try {
    const errors = [];
{{#each entity.fields}}
{{#if this.required}}
    if (!req.body.{{camelCase this.name}} && req.body.{{camelCase this.name}} !== 0) errors.push('{{this.name}} is required');
{{/if}}
{{/each}}
    if (errors.length) return res.status(400).json({ error: 'Validation failed', details: errors });

    const item = new {{pascalCase entity.name}}(req.body);
    await item.save();
    res.status(201).json(item);
  } catch (error) {
    if (error.name === 'ValidationError') return res.status(400).json({ error: error.message });
    if (error.code === 11000) {
      const field = Object.keys(error.keyValue)[0];
      return res.status(409).json({ error: `A {{entity.name}} with this ${field} already exists` });
    }
    res.status(500).json({ error: error.message });
  }
};

// Update {{entity.name}}
exports.update = async (req, res) => {
  try {
    const item = await {{pascalCase entity.name}}.findByIdAndUpdate(
      req.params.id, req.body, { new: true, runValidators: true }
    );
    if (!item) return res.status(404).json({ error: '{{pascalCase entity.name}} not found' });
    res.json(item);
  } catch (error) {
    if (error.name === 'ValidationError') return res.status(400).json({ error: error.message });
    if (error.code === 11000) {
      const field = Object.keys(error.keyValue)[0];
      return res.status(409).json({ error: `A {{entity.name}} with this ${field} already exists` });
    }
    res.status(500).json({ error: error.message });
  }
};

// Delete {{entity.name}}
exports.remove = async (req, res) => {
  try {
    const item = await {{pascalCase entity.name}}.findByIdAndDelete(req.params.id);
    if (!item) return res.status(404).json({ error: '{{pascalCase entity.name}} not found' });
    res.json({ message: '{{pascalCase entity.name}} deleted successfully' });
  } catch (error) {
    if (error.name === 'CastError') return res.status(400).json({ error: 'Invalid ID format' });
    res.status(500).json({ error: error.message });
  }
};

// Get statistics for {{entity.name}}
exports.getStats = async (req, res) => {
  try {
    const total = await {{pascalCase entity.name}}.countDocuments();
    const thisMonth = await {{pascalCase entity.name}}.countDocuments({
      createdAt: { $gte: new Date(new Date().getFullYear(), new Date().getMonth(), 1) }
    });
    const stats = { total, thisMonth };
{{#each entity.fields}}
{{#ifEq this.type "Enum"}}
    stats.by{{pascalCase this.name}} = await {{pascalCase ../entity.name}}.aggregate([
      { $group: { _id: '${{camelCase this.name}}', count: { $sum: 1 } } },
      { $sort: { count: -1 } }
    ]);
{{/ifEq}}
{{#ifEq this.type "Number"}}
    const {{camelCase this.name}}Agg = await {{pascalCase ../entity.name}}.aggregate([
      { $group: { _id: null, total: { $sum: '${{camelCase this.name}}' }, avg: { $avg: '${{camelCase this.name}}' }, min: { $min: '${{camelCase this.name}}' }, max: { $max: '${{camelCase this.name}}' } } }
    ]);
    stats.{{camelCase this.name}} = {{camelCase this.name}}Agg[0] || {};
{{/ifEq}}
{{/each}}
    res.json(stats);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

// Bulk create {{pluralize entity.name}}
exports.bulkCreate = async (req, res) => {
  try {
    const records = req.body;
    if (!Array.isArray(records) || !records.length) {
      return res.status(400).json({ error: 'Request body must be a non-empty array' });
    }
    if (records.length > 500) {
      return res.status(400).json({ error: 'Bulk create is limited to 500 records per request' });
    }

    const errors = [];
    const valid = [];
    records.forEach((rec, i) => {
      const recErrors = [];
{{#each entity.fields}}
{{#if this.required}}
      if (!rec.{{camelCase this.name}} && rec.{{camelCase this.name}} !== 0) recErrors.push('{{this.name}} is required');
{{/if}}
{{/each}}
      if (recErrors.length) errors.push({ index: i, errors: recErrors });
      else valid.push(rec);
    });

    if (errors.length && valid.length === 0) {
      return res.status(400).json({ error: 'Validation failed for all records', details: errors });
    }

    const inserted = await {{pascalCase entity.name}}.insertMany(valid, { ordered: false });

    res.status(201).json({
      inserted: inserted.length,
      failed: errors.length,
      errors: errors.length ? errors : undefined,
      data: inserted
    });
  } catch (error) {
    if (error.name === 'MongoBulkWriteError') {
      return res.status(207).json({
        error: 'Some records failed',
        inserted: error.result?.nInserted || 0,
        details: error.writeErrors?.map(e => ({ index: e.index, message: e.errmsg }))
      });
    }
    res.status(500).json({ error: error.message });
  }
};

// Export data
exports.exportData = async (req, res) => {
  try {
    const items = await {{pascalCase entity.name}}.find(){{#each entity.fields}}{{#if this.ref}}.populate('{{camelCase this.name}}'){{/if}}{{/each}}.lean();
    res.setHeader('Content-Disposition', 'attachment; filename={{kebabCase (pluralize entity.name)}}.json');
    res.json(items);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};
